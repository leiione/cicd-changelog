# VISP Tickets Micro-Frontend Project Context

## Project Overview
- **Name**: Tickets Micro-Frontend
- **Purpose**: Ticket management system as part of the VISP platform
- **Type**: Micro-frontend application
- **Repository**: VISPdevteam/Tickets-Mircro-Frontend
- **Version**: 0.1.0

## Tech Stack
- **Framework**: React
- **UI Library**: Material UI (MUI) v5.14
  - MUI Data Grid Pro for data tables
  - MUI Date Pickers for date handling
  - MUI Tree View for hierarchical data
- **State Management**: 
  - Redux Toolkit for global state
  - Apollo Client for GraphQL state
- **Data Management**: 
  - Apollo Client v3.8.6 for GraphQL
  - GraphQL WebSocket support
- **Icons**: FontAwesome Pro v6.6
- **CI/CD**: CircleCI
- **Date Handling**: date-fns, dayjs
- **Rich Text Editing**: TinyMCE React
- **PDF Generation**: jsPDF
- **Testing**: Jest with React Testing Library

## Key Features
- Installer Availability Management
  - Schedule off-time management
  - Availability tracking
- Ticket Management
  - Add new tickets
  - View ticket details
  - Rich text editing support
  - PDF export capabilities
- Common Features
  - Global snackbar notifications
  - Data grid views
  - Date/time handling
  - Tree view navigation

## Project Structure
```
src/
├── AddTicket/           # New ticket creation feature
├── Common/              # Shared components and utilities
├── InstallerAvailbility/# Installer scheduling feature
│   └── components/      # Reusable components
│       └── ScheduleOffTimeDrawer.js  # Off-time management
├── TicketDetails/       # Ticket viewing and management
├── assets/             # Static assets and resources
├── components/         # Global components
├── config/             # Configuration files
│   ├── apollo.js       # Apollo GraphQL client configuration
│   └── store.js        # Redux store configuration
└── utils/              # Utility functions
```

## Architecture Patterns
- Micro-frontend architecture using module federation
- GraphQL for data fetching with WebSocket support
- Component-based structure with feature-based organization
- Redux for global state management
- Material UI theming with custom production prefix (crmMF-)
- Event-driven communication using Redux and Apollo subscriptions

## Coding Standards
- Component Structure:
  - Feature-based directory organization
  - Shared components in Common directory
  - Container/Component pattern
- Naming Conventions:
  - PascalCase for components
  - camelCase for functions and variables
  - Feature-based directory names
- State Management:
  - Redux for global UI state
  - Apollo Client for server state
  - Local state for component-specific data
- Error Handling:
  - Global snackbar for user notifications
  - GraphQL error handling through Apollo

## Implementation Patterns and Conventions

### GraphQL Patterns
1. GraphQL files are organized by feature (TicketGraphQL.js, InstallerGraphQL.js)
2. Real-time updates use GraphQL subscriptions for:
   - Ticket updates
   - Notes, SMS, and Email messages
   - Tasks and Custom Fields
   - Attachments and History
   - Linked Tickets

### Component Patterns
1. Common Components:
   - AccordionCard - Expandable sections
   - AvatarText - User avatars with text
   - ButtonWithLabel - Standard button with label
   - GlobalSnackbar - Application-wide notifications
   - InnerDrawer - Nested drawer components
   - Loader - Loading states
   - ProgressButton - Buttons with loading states

2. Form Field Patterns:
   - Hook-based form fields for consistency
   - Specialized fields:
     - Address geocoding (HookAddressGeocoderField)
     - IP address validation (HookIPAddressField)
     - MAC address formatting (HookMacAddressField)
     - Type-ahead for email and SMS (HookTypeAheadEmailField, HookTypeAheadSMSField)
     - Autocomplete with ZIP code validation (HookAutoCompleteZipField)
     - Basic form controls (HookTextField, HookNumberField, HookCheckbox, HookSwitch)

3. Data Grid Patterns:
   - Uses MUI X-Data-Grid-Pro
   - Custom table implementations in DataGridTable/

### Feature Implementation Patterns
1. Ticket Management:
   - CRUD operations via GraphQL
   - File attachments with upload mutation
   - Custom fields support
   - Email templates system
   - Task management
   - Linking tickets functionality
   - Activity history tracking

2. Installer Availability:
   - Schedule management
   - Off-time tracking
   - Real-time updates

3. User Preferences:
   - Persistent user settings
   - Preference synchronization

### Common Utils and Helpers
1. Constants file for shared values
2. Helper functions for common operations
3. Utility functions organized by feature

### State Management Patterns
1. Apollo Client:
   - Cached queries
   - Optimistic updates
   - Real-time subscriptions
2. Redux:
   - User preferences
   - Global UI state
   - Snackbar notifications

### Error Handling Patterns
1. Global error boundary
2. GraphQL error handling
3. Form validation
4. Network error recovery

### Component Organization
1. Feature-based directory structure
2. Common components in shared directory
3. Hook-based form fields
4. Utility functions per feature

### Best Practices
1. Use hook-based form fields for consistency
2. Implement real-time updates via subscriptions
3. Centralize common components
4. Use type-ahead for better UX
5. Implement proper error handling
6. Follow established naming conventions
7. Use drawer pattern for complex forms
8. Implement loading states for better UX

### Important Note
Before implementing any feature:
1. Review all requirements thoroughly
2. If any aspect is unclear or ambiguous, ask for clarification
3. Don't make assumptions - when in doubt, ask!